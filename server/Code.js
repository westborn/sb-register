this.CONFIG = {
	ARTIST_REG_SHEET_ID: '1faNJ7Q2x_a4WO0O919487dDrg_0Ky6Y4xiab8Io0_N0',
	SAMPLE_REGISTRATION: {
		registrationId: 'R23001',
		firstName: 'll',
		lastName: 'll',
		phone: 'll',
		email: 'ff',
		postcode: 'ff',
		bumpIn: 'gg',
		bumpOut: 'gg',
		crane: 'gg',
		displayRequirements: 'gg',
		bankAccountName: 'gg',
		bankBSB: 'gg',
		bankAccount: 'gg',
		transport: 'gg',
		accommodation: 'gg',
		confirmation: 'gg'
	},

	// data:image/jpeg;base64,

	SAMPLE_IMAGE: {
		imageId: 'I23-001',
		entryId: 'E23-001',
		imageURL: 'https://drive.google.com/open?id=1IZcQzGc-78gBXisTbaYtHHaxqXYy-BfB',
		imageFileName: 'aaWatts_Spirali Ligna_217f1f16-20f4-4a3a-9a45-2dbdc0673b3f',
		originalFileName: 'Watts_Spirali Ligna_217f1f16-20f4-4a3a-9a45-2dbdc0673b3f',
		mimetype: 'JPG',
		blobDataURL:
			'data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABQAAD/4QMhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9Ik9MWU1QVVMgTWFzdGVyIDEuNDEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTJGNUY0RThFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTJGNUY0RTlFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFMkY1RjRFNkU3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFMkY1RjRFN0U3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/tAEhQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAADxwBWgADGyVHHAIAAAIAAgA4QklN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'
	},
	SAMPLE_ADD_ENTRY: {
		newEntry: {
			entryId: 'NotSet',
			registrationId: 'R23-008',
			inOrOut: 'Outdoor',
			email: 'george@westborn.com.au',
			title: 'Anticipation xx',
			material: 'Glass fibre reinforced concrete, patina',
			dimensions: '63 x 30 x 52',
			description:
				'Samuel Johnson famously said: “The present time is seldom able to fill desire or imagination with immediate enjoyment, and we are forced to supply its deficiencies by recollection or anticipation.” This sculpture depicts a moment of heightened curiosity and anticipation so vividly demonstrated by our canine quadrupeds.',
			specialRequirements: 'none',
			price: 1900
		},
		newImage: {
			imageId: 'NoImage',
			entryId: 'NotSet',
			imageURL: '',
			imageFileName: 'Watts_Anticipation xx_',
			originalFileName: 'georgephoto.jpg',
			blobDataURL:
				'data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABQAAD/4QMhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9Ik9MWU1QVVMgTWFzdGVyIDEuNDEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTJGNUY0RThFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTJGNUY0RTlFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFMkY1RjRFNkU3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFMkY1RjRFN0U3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/tAEhQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAADxwBWgADGyVHHAIAAAIAAgA4QklN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'
		}
	}
}

function test() {
	const ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
	// const res = getInformationForEmailAddress({ email: 'george@westborn.com.au' }, ss)
	// console.log(JSON.stringify(JSON.parse(res.getContent()), null, 2))
	// return

	const entryToAdd = {
		data: CONFIG.SAMPLE_ADD_ENTRY
	}

	res = createEntry(entryToAdd.data, ss)
	console.log(res.getContent())

	return

	// id, entryId, originalFileName, email, blobDataURL, imageFileName: artistSurname_title_id
	const imagesFolderName = 'Entry Images'
	const originalFileName = CONFIG.SAMPLE_IMAGE.imageFileName
	const imageFileName = CONFIG.SAMPLE_IMAGE.imageFileName
	const blobDataURL = CONFIG.SAMPLE_IMAGE.blobDataURL

	// establish the image folder id
	const myFolder = wbLib.getMyFolder(ss)
	const imagesFolder = wbLib.checkIfFolderExistElseCreate(myFolder, imagesFolderName)

	// make a named blob from the dataURL from the user
	const { blob } = dataURLtoBlob(blobDataURL)
	blob.setName(imageFileName)

	// determine if an originalFileName file currently exists
	const fileIterator = imagesFolder.getFilesByName(originalFileName)
	const fileId = fileIterator.hasNext() ? fileIterator.next().getId() : ''

	// either create a file or update the existing one
	const fileClass =
		fileId === ''
			? imagesFolder.createFile(blob)
			: DriveApp.getFileById(Drive.Files.update({ title: imageFileName }, fileId, blob).id)

	console.log(fileClass)

	// console.log(blob.getContentType())

	// const sheet = ss.getSheetByName('Entries')

	// const myFolder = wbLib.getMyFolder(sheet)
	// const folder = wbLib.checkIfFolderExistElseCreate(myFolder, "Entry Images")
	// console.log(folder.getName())

	// const res = createRegistration(CONFIG.SAMPLE_REGISTRATION, ss)
	// console.log(res)

	// const res = createEntry(CONFIG.SAMPLE_ENTRY, ss)
	// console.log(res)

	// var res = deleteEntry({ id: "da285873-332f-496c-8692-78c011deda9d" }, ss)
	// console.log(res)

	// var ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
	// const sheet = ss.getSheetByName('Entries')
	// const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
	// console.log(headers)
	// const row = headers.map((key) => CONFIG.SAMPLE_ENTRY[String(key)] || '')
	// console.log(row)
	// return

	// var res = deleteEntry({ id: "da285873-332f-496c-8692-78c011deda9d" }, ss)
	// console.log(res)

	// // saved code here VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	// var sheet = ss.getSheetByName('Entries')
	// var dataRange = sheet.getDataRange()
	// var data = dataRange.getValues()
	// var headings = data[0]
	// var allData = wbLib.getJsonArrayFromData(data)
	// var res = allData.filter(item => item.id !== request.id)
	// var rowData = res.map((row) => headings.map((key) => row[String(key)] || ''))
	// //clear the sheet (not headings)
	// dataRange.offset(1, 0).clearContent();
	// // write result
	// sheet.getRange(sheet.getLastRow() + 1, 1, rowData.length, rowData[0].length).setValues(rowData)
	// return sendResponse('ok', { id: request.id })
}

function doPost(e) {
	// API Construction

	// Action: String
	//     getDetailsByEmail
	//     createEntry
	//     deleteEntry
	//     modifyEntry
	//     createRegistration
	//     modifyRegistration
	//     createImage
	//
	// Data: various Objects
	//
	// Response
	//   {result: status, {
	//     data: {
	//       registration: registrationArray[0],
	//       entries: [...entryArray]
	//     }
	//    }
	//   }

	try {
		const ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
		const request = JSON.parse(e.postData.contents)
		var result
		switch (request.action) {
			case 'getDetailsByEmail':
				result = getInformationForEmailAddress(request.data.email, ss)
				break
			case 'createEntry':
				result = createEntry(request.data, ss)
				break
			case 'deleteEntry':
				result = deleteEntry(request.data, ss)
				break
			case 'modifyEntry':
				result = modifyEntry(request.data, ss)
				break
			case 'createRegistration':
				result = createRegistration(request.data, ss)
				break
			case 'modifyRegistration':
				result = modifyRegistration(request.data, ss)
				break
			case 'completeRegistration':
				result = completeRegistration(request.data, ss)
				break
			case 'createImage':
				result = createImage(request.data, ss)
				break
			default:
				console.log(request.data)
				result = sendResponse('error', 'Unknown Function')
				break
		}
	} catch (err) {
		console.log(err)
		result = sendResponse('error', err)
	}
	return result
}

function createImage(imageObject, ss) {
	const newImage = {
		imageId: imageObject.imageId,
		entryId: imageObject.entryId,
		imageURL: '',
		imageFileName: imageObject.imageFileName + imageObject.imageId,
		originalFileName: imageObject.originalFileName
	}

	// TODO Validate image
	try {
		const imagesFolderName = 'Entry Images'
		// establish the image folder id
		const myFolder = wbLib.getMyFolder(ss)
		const imagesFolder = wbLib.checkIfFolderExistElseCreate(myFolder, imagesFolderName)
		// make a named blob from the dataURL from the user
		const { blob, mimeType } = dataURLtoBlob(imageObject.blobDataURL)
		blob.setName(newImage.imageFileName)
		// determine if an image file currently exists
		const fileIterator = imagesFolder.getFilesByName(newImage.imageFileName)
		const fileId = fileIterator.hasNext() ? fileIterator.next().getId() : ''
		console.log('fileId', fileId)
		// either create a file or update the existing one
		const fileClass =
			fileId === ''
				? imagesFolder.createFile(blob)
				: DriveApp.getFileById(
						Drive.Files.update({ title: newImage.imageFileName }, fileId, blob).id
				  )
		// get the URL to the image file
		newImage.imageURL = `https://drive.google.com/open?id=${fileClass.getId()}`

		const sheet = ss.getSheetByName('Images')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]

		// // update the entry row
		// const rowToChange = wbLib.getRowFromColumnSearch(sheet.getDataRange().getValues(), "imageId", imageId)
		// if (rowToChange) {
		//   // update columns - imageURL, originalFileName
		//   imageURLColumn = headers.indexOf('imageURL') + 1
		//   sheet.getRange(rowToChange, imageURLColumn).setValues(newImage.imageURL)

		//   originalFileNameColumn = headers.indexOf('originalFileName') + 1
		//   sheet.getRange(rowToChange, imageURLColumn).setValues(imageObject.originalFileName)
		// }

		const row = headers.map((key) => newImage[String(key)] || '')
		sheet.appendRow(row)
	} catch (err) {
		console.log(err)
		return null
	}
	return newImage
}

function modifyImage(imageObject, ss) {
	const newImage = {
		imageId: imageObject.imageId,
		entryId: imageObject.entryId,
		imageURL: imageObject.imageURL,
		imageFileName: imageObject.imageFileName,
		originalFileName: imageObject.originalFileName
	}

	// TODO Validate image
	try {
		const imagesFolderName = 'Entry Images'
		// establish the image folder id
		const myFolder = wbLib.getMyFolder(ss)
		const imagesFolder = wbLib.checkIfFolderExistElseCreate(myFolder, imagesFolderName)
		// make a named blob from the dataURL from the user
		const { blob, mimeType } = dataURLtoBlob(imageObject.blobDataURL)
		blob.setName(newImage.imageFileName)
		// determine if an image file currently exists
		const fileIterator = imagesFolder.getFilesByName(newImage.imageFileName)
		const fileId = fileIterator.hasNext() ? fileIterator.next().getId() : ''
		console.log('fileId', fileId)
		// either create a file or update the existing one
		const fileClass =
			fileId === ''
				? imagesFolder.createFile(blob)
				: DriveApp.getFileById(
						Drive.Files.update({ title: newImage.imageFileName }, fileId, blob).id
				  )
		// get the URL to the image file
		newImage.imageURL = `https://drive.google.com/open?id=${fileClass.getId()}`

		const sheet = ss.getSheetByName('Images')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]

		// update the entry row
		const rowToChange = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'imageId',
			imageObject.imageId
		)
		if (rowToChange) {
			// update columns - imageURL, originalFileName
			const imageURLColumn = headers.indexOf('imageURL') + 1
			sheet.getRange(rowToChange, imageURLColumn, 1, 1).setValue(newImage.imageURL)

			const originalFileNameColumn = headers.indexOf('originalFileName') + 1
			sheet
				.getRange(rowToChange, originalFileNameColumn, 1, 1)
				.setValue(imageObject.originalFileName)
		}
	} catch (err) {
		console.log(err)
		return null
	}
	return newImage
}

function createRegistration(request, ss) {
	console.log('createRegistration', request)
	// TODO Validate entry
	if (!request.registrationId || request.registrationId.trim() === '') {
		return sendResponse('error', 'Invalid ID for create')
	}
	//create unique Regsitration ID
	request.registrationId = bumpId('registrationId')
	try {
		const sheet = ss.getSheetByName('Registrations')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		sheet.appendRow(row)
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		return sendErrorResponse(err)
	}
}

function modifyRegistration(request, ss) {
	console.log('modifyRegistration', request)

	if (!request.registrationId || request.registrationId.trim() === '') {
		return sendResponse('error', 'Invalid ID for modify')
	}
	try {
		const sheet = ss.getSheetByName('Registrations')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		console.log('modifyRegistration')
		console.log(row)
		const rowToModify = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'registrationId',
			request.registrationId
		)
		if (rowToModify) {
			sheet.getRange(rowToModify, 1, 1, row.length).setValues([row])
		}
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		return sendErrorResponse(err)
	}
}

function completeRegistration(request, ss) {
	console.log('completeRegistration', request)

	if (!request.registrationId || request.registrationId.trim() === '') {
		return sendResponse('error', 'Invalid ID for complete')
	}
	try {
		const sheet = ss.getSheetByName('Registrations')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		console.log('completeRegistration')
		console.log(row)
		const rowToModify = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'registrationId',
			request.registrationId
		)
		if (rowToModify) {
			const columnNumber = headers.indexOf('confirmation') + 1
			sheet.getRange(rowToModify, columnNumber, 1, 1).setValue('Complete')
		}
		sendRegistrationConfirmationEmail(ss, request.email)
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		return sendErrorResponse(err)
	}
}

function createEntry(data, ss) {
	// TODO Validate entry

	const newEntry = data.newEntry
	newEntry['price'] = Number(newEntry['price'].replace(/[^0-9\.]+/g, ''))
	const newImage = data.newImage
	newEntry.entryId = bumpId('entryId')
	try {
		const sheet = ss.getSheetByName('Entries')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => newEntry[String(key)] || '')
		sheet.appendRow(row)
	} catch (err) {
		console.log(err)
		return null
	}

	//we've added the entry - now add the image
	// entryId, originalFileName, email, blobDataURL, imageFileName: artistSurname_title_

	newImage.entryId = newEntry.entryId
	newImage.imageId = bumpId('imageId')
	const res = createImage(newImage, ss)
	console.log('image created', res)
	const response = getFullRegistration(newEntry.email, ss)
	return sendResponse('ok', response.data)
}

function deleteEntry(request, ss) {
	console.log('deleteEntry', request)

	if (!request.entryId || request.entryId.trim() === '') {
		return sendResponse('error', 'Invalid ID for delete')
	}
	try {
		//delete the Entry
		const sheetEntry = ss.getSheetByName('Entries')
		const rowToDeleteEntry = wbLib.getRowFromColumnSearch(
			sheetEntry.getDataRange().getValues(),
			'entryId',
			request.entryId
		)
		if (rowToDeleteEntry) {
			sheetEntry.deleteRow(rowToDeleteEntry)
		}

		//delete associated Image
		const sheetImage = ss.getSheetByName('Images')
		const rowToDeleteImage = wbLib.getRowFromColumnSearch(
			sheetImage.getDataRange().getValues(),
			'imageId',
			request.imageId
		)
		if (rowToDeleteImage) {
			sheetImage.deleteRow(rowToDeleteImage)
		}

		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		return sendErrorResponse(err)
	}
}

function modifyEntry(request, ss) {
	console.log('modifyEntry', request)

	if (!request.entryId || request.entryId.trim() === '') {
		return sendResponse('error', 'Invalid ID for modify')
	}
	try {
		const sheet = ss.getSheetByName('Entries')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		request['price'] = Number(request['price'].replace(/[^0-9\.]+/g, ''))
		const row = headers.map((key) => request[String(key)] || '')
		console.log('modifyEntry')
		console.log(row)
		const rowToModify = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'entryId',
			request.entryId
		)
		if (rowToModify) {
			sheet.getRange(rowToModify, 1, 1, row.length).setValues([row])
		}

		//now see if we need to update the image associated
		if (request.image) {
			try {
				modifyImage(request.image, ss)
			} catch (err) {
				return sendErrorResponse(err)
			}
		}

		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		return sendErrorResponse(err)
	}
}

function sendRegistrationConfirmationEmail(
	ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID),
	email = 'george@westborn.com.au'
) {
	const {
		data: { registration: registrationData },
		data: { entries: entriesData }
	} = getFullRegistration(email, ss)
	const registrationHTML = makeRegistrationHTML(registrationData)
	const entriesHTML = makeEntriesHTML(entriesData)
	const costOfRegistration = 20 + entriesData.length * 20
	const numberOfEntries = entriesData.length === 1 ? `1 entry` : `${entriesData.length} entries`
	const headerHTML = ` <p style="color: #1d4ed8; font-size: 30px;">Registration for ${registrationData.firstName} ${registrationData.lastName} (${registrationData.registrationId})</p>
      <p style="color: #1d4ed8; font-size: 18px;">Your registration of ${numberOfEntries} has a total fee of $${costOfRegistration}</p>
    `

	const htmlBody = headerHTML + registrationHTML + '<hr>' + entriesHTML

	GmailApp.sendEmail(
		registrationData.email,
		'Registration confirmation for Sculpture Bermagui',
		'body text',
		{
			htmlBody,
			replyTo: 'curator@sculpturebermagui.org.au'
		}
	)
}

function makeRegistrationHTML(registrationData) {
	const regFields = [
		['Email', 'email'],
		['Phone', 'phone'],
		['Postcode', 'postcode'],
		['Bank Account', 'bankAccountName'],
		['BSB', 'bankBSB'],
		['Account', 'bankAccount'],
		['Transport', 'transport'],
		['Accommodation', 'accommodation'],
		['Crane', 'crane'],
		['Bump In', 'bumpIn'],
		['Bump Out', 'bumpOut'],
		['Requirements', 'displayRequirements']
	]

	const registrationHTML = `
  <table style="font-family:\'Arial\';border-collapse:collapse;border-spacing:0;"><tbody>
  ${makeTableRows(regFields, registrationData)}
  </tbody></table>
  `
	return registrationHTML
}

function makeEntriesHTML(entriesData) {
	const entryFields = [
		['Indoor/Outdoor', 'inOrOut'],
		['Entry Title', 'title'],
		['Entry Description', 'description'],
		['Material', 'material'],
		['Dimensions', 'dimensions'],
		['Special Requirements', 'specialRequirements']
	]
	const priceField = [['Price', 'price']]

	const entryHTML = entriesData
		.map(
			(entry, idx) =>
				`
  <hr>
  <p style="color: #1d4ed8; font-size: 20px;">Entry # ${idx + 1}<br/>
  <table style="font-family:\'Arial\';border-collapse:collapse;border-spacing:0;"><tbody>
	${makeTableRows(entryFields, entry)}
  ${makeTableRows(priceField, {
		price: entry.price.toLocaleString('en-AU', {
			style: 'currency',
			currency: 'AUD'
		})
	})}
  </tbody></table>
  <br/>
  <img src="${getViewURL(entry.images[0].imageURL)}" width="200">
  <br/>
  `
		)
		.join('')

	return entryHTML
}

function makeTableRows(fields, data) {
	return fields
		.map(
			([name, value]) => `
    <tr>
    <td style="width:150px;border-style:none;text-align:left;padding-right:2px;padding-left:2px;background-color:#ffffff;color:#1d4ed8;" >
    ${name}
    </td>
    <td style="width:450px;border-style:none;text-align:left;padding-right:2px;padding-left:2px;background-color:#ffffff;color:#111827;" >
    ${data[value]}
    </td>
    </tr>
  `
		)
		.join('')
}

function getInformationForEmailAddress(email, ss) {
	if (!email || email.trim() === '') {
		return sendResponse('error', 'No email provided or invalid email address')
	}
	//now get the registration and all entries
	const response = getFullRegistration(email, ss)
	return sendResponse('ok', response.data)
}

function getFullRegistration(email, ss) {
	var registrationArray = getRegistrationByEmail(email, ss)
	if (typeof registrationArray !== 'undefined' && registrationArray.length !== 1) {
		return { data: { registration: {}, entries: [] } }
	}
	var entryArray = getEntriesByEmail(email, ss)
	return {
		data: { registration: registrationArray[0], entries: [...entryArray] }
	}
}

function getRegistrationByEmail(email, ss) {
	var registrationSheet = ss.getSheetByName('Registrations')
	const registrationData = registrationSheet.getDataRange().getValues()
	const allRegistrations = wbLib.getJsonArrayFromData(registrationData)
	var res = allRegistrations.filter((item) => item.email === email)
	return res
}

function getEntriesByEmail(email, ss) {
	const entrySheet = ss.getSheetByName('Entries')
	const entryData = entrySheet.getDataRange().getValues()
	const allEntries = wbLib.getJsonArrayFromData(entryData)

	const imageSheet = ss.getSheetByName('Images')
	const imageData = imageSheet.getDataRange().getValues()
	const allImages = wbLib.getJsonArrayFromData(imageData)

	// just the entries for the email we have
	const entriesForThisEmail = allEntries.filter((entry) => entry.email === email)

	// get the images linked with the entry id
	const entries = entriesForThisEmail.map((entry) => {
		const images = allImages.filter((imageItem) => imageItem.entryId === entry.entryId)
		return { ...entry, images }
	})

	// console.log(JSON.stringify(entries,null,2))
	return entries
}

function sendResponse(status, data) {
	try {
		return ContentService.createTextOutput(
			JSON.stringify({ result: status, data: data })
		).setMimeType(ContentService.MimeType.JSON)
	} catch (err) {
		console.log(err)
		return ContentService.createTextOutput(
			JSON.stringify({ result: 'error', data: err })
		).setMimeType(ContentService.MimeType.JSON)
	}
}

function sendErrorResponse(err) {
	console.log(err)
	return sendResponse('error', `${err.name} - ${err.message} - ${err.stack}`)
}

//**dataURL to blob**
function dataURLtoBlob(dataurl) {
	const arr = dataurl.split(',')
	const mimeType = arr[0].match(/:(.*?);/)[1]
	const myBlob = Utilities.base64Decode(arr[1])
	return {
		blob: Utilities.newBlob(myBlob, mimeType),
		mimeType
	}
}

/**
 * IDs are stored in a script property store using library functions
 *
 * ID is of the form 'xyzzy-nnn'
 * xyzzy can be any string  (not containing hyphen)
 * nnn is incrmented by 1
 *
 *
 * @param idType:String (registrationId | entryId | imageId)
 * @returns id:String
 *
 */
function bumpId(idType) {
	const prop = PropertiesService.getScriptProperties()
	const currentId = wbLib.getProp(idType, prop)
	let [frontPart, id] = currentId.split(/[/-]/)
	//increment the id part by 1 and zero fill to 3 chars
	const newId = (parseInt(id, 10) + 1).toString().padStart(3, '0')
	wbLib.setProp(idType, `${frontPart}-${newId}`, prop)
	return `${frontPart}-${newId}`
}

function getIdFromUrl(url) {
	return url.match(/[-\w]{25,}(?!.*[-\w]{25,})/)
}

function getViewURL(url) {
	return `https://drive.google.com/uc?export=view&id=${getIdFromUrl(url)}`
}
