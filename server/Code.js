this.CONFIG = {
	ARTIST_REG_SHEET_ID: '1faNJ7Q2x_a4WO0O919487dDrg_0Ky6Y4xiab8Io0_N0',
	SAMPLE_ENTRY: {
		entryId: 'E23-001',
		inOrOut: 'Outdoor',
		email: 'george@westborn.com.au',
		title: 'Anticipation',
		material: 'Glass fibre reinforced concrete, patina',
		dimensions: '63 x 30 x 52',
		description:
			'Samuel Johnson famously said: “The present time is seldom able to fill desire or imagination with immediate enjoyment, and we are forced to supply its deficiencies by recollection or anticipation.” This sculpture depicts a moment of heightened curiosity and anticipation so vividly demonstrated by our canine quadrupeds.',
		specialRequirements: 'none',
		price: 1900,
		imageURL: 'https://drive.google.com/open?id=1DysBG45U8FbBFb_tJJqAnbsWr-fP2dCg',
		originalFileName: 'filename'
	},
	SAMPLE_REGISTRATION: {
		registrationId: 'R23001',
		firstName: 'll',
		lastName: 'll',
		phone: 'll',
		email: 'ff',
		postcode: 'ff',
		bumpIn: 'gg',
		bumpOut: 'gg',
		crane: 'gg',
		displayRequirements: 'gg',
		bankAccountName: 'gg',
		bankBSB: 'gg',
		bankAccount: 'gg',
		transport: 'gg',
		accommodation: 'gg',
		confirmation: 'gg'
	},

	// data:image/jpeg;base64,

	SAMPLE_IMAGE: {
		imageId: 'I23-001',
		entryId: 'E23-001',
		imageURL: 'https://drive.google.com/open?id=1IZcQzGc-78gBXisTbaYtHHaxqXYy-BfB',
		imageFileName: 'aaWatts_Spirali Ligna_217f1f16-20f4-4a3a-9a45-2dbdc0673b3f',
		originalFileName: 'Watts_Spirali Ligna_217f1f16-20f4-4a3a-9a45-2dbdc0673b3f',
		mimetype: 'JPG',
		blobDataURL:
			'data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAABQAAD/4QMhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9Ik9MWU1QVVMgTWFzdGVyIDEuNDEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RTJGNUY0RThFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RTJGNUY0RTlFN0EzMTFFMThERTBGRTAxODgwNkZFQ0YiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpFMkY1RjRFNkU3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpFMkY1RjRFN0U3QTMxMUUxOERFMEZFMDE4ODA2RkVDRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pv/tAEhQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAADxwBWgADGyVHHAIAAAIAAgA4QklN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'
	}
}

function test() {
	const ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
	// const res = getInformationForEmailAddress({ email: 'george@westborn.com.au' }, ss)
	// console.log(JSON.stringify(JSON.parse(res.getContent()), null, 2))
	// return

	// id, entryId, originalFileName, email, blobDataURL, imageFileName: artistSurname_title_id
	const imagesFolderName = 'Entry Images'
	const originalFileName = CONFIG.SAMPLE_IMAGE.imageFileName
	const imageFileName = CONFIG.SAMPLE_IMAGE.imageFileName
	const blobDataURL = CONFIG.SAMPLE_IMAGE.blobDataURL

	// establish the image folder id
	const myFolder = wbLib.getMyFolder(ss)
	const imagesFolder = wbLib.checkIfFolderExistElseCreate(myFolder, imagesFolderName)

	// make a named blob from the dataURL from the user
	const { blob } = dataURLtoBlob(blobDataURL)
	blob.setName(imageFileName)

	// determine if an originalFileName file currently exists
	const fileIterator = imagesFolder.getFilesByName(originalFileName)
	const fileId = fileIterator.hasNext() ? fileIterator.next().getId() : ''

	// either create a file or update the existing one
	const fileClass =
		fileId === ''
			? imagesFolder.createFile(blob)
			: DriveApp.getFileById(Drive.Files.update({ title: imageFileName }, fileId, blob).id)

	console.log(fileClass)

	// console.log(blob.getContentType())

	// const sheet = ss.getSheetByName('Entries')

	// const myFolder = wbLib.getMyFolder(sheet)
	// const folder = wbLib.checkIfFolderExistElseCreate(myFolder, "Entry Images")
	// console.log(folder.getName())

	// const res = createRegistration(CONFIG.SAMPLE_REGISTRATION, ss)
	// console.log(res)

	// const res = createEntry(CONFIG.SAMPLE_ENTRY, ss)
	// console.log(res)

	// var res = deleteEntry({ id: "da285873-332f-496c-8692-78c011deda9d" }, ss)
	// console.log(res)

	// var ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
	// const sheet = ss.getSheetByName('Entries')
	// const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
	// console.log(headers)
	// const row = headers.map((key) => CONFIG.SAMPLE_ENTRY[String(key)] || '')
	// console.log(row)
	// return

	// var res = deleteEntry({ id: "da285873-332f-496c-8692-78c011deda9d" }, ss)
	// console.log(res)

	// // saved code here VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
	// var sheet = ss.getSheetByName('Entries')
	// var dataRange = sheet.getDataRange()
	// var data = dataRange.getValues()
	// var headings = data[0]
	// var allData = wbLib.getJsonArrayFromData(data)
	// var res = allData.filter(item => item.id !== request.id)
	// var rowData = res.map((row) => headings.map((key) => row[String(key)] || ''))
	// //clear the sheet (not headings)
	// dataRange.offset(1, 0).clearContent();
	// // write result
	// sheet.getRange(sheet.getLastRow() + 1, 1, rowData.length, rowData[0].length).setValues(rowData)
	// return sendResponse('ok', { id: request.id })
}

function doPost(e) {
	// API Construction

	// Action: String
	//     getDetailsByEmail
	//     createEntry
	//     deleteEntry
	//     modifyEntry
	//     createRegistration
	//     modifyRegistration
	//     createImage
	//
	// Data: various Objects
	//
	// Response
	//   {result: status, {
	//     data: {
	//       registration: registrationArray[0],
	//       entries: [...entryArray]
	//     }
	//    }
	//   }

	try {
		const ss = SpreadsheetApp.openById(CONFIG.ARTIST_REG_SHEET_ID)
		const request = JSON.parse(e.postData.contents)
		var result
		switch (request.action) {
			case 'getDetailsByEmail':
				result = getInformationForEmailAddress(request.data, ss)
				break
			case 'createEntry':
				result = createEntry(request.data, ss)
				break
			case 'deleteEntry':
				result = deleteEntry(request.data, ss)
				break
			case 'modifyEntry':
				result = modifyEntry(request.data, ss)
				break
			case 'createRegistration':
				result = createRegistration(request.data, ss)
				break
			case 'modifyRegistration':
				result = modifyRegistration(request.data, ss)
				break
			case 'createImage':
				result = createImage(request.data, ss)
				break
			default:
				console.log(request.data)
				result = sendResponse('error', 'Unknown Function')
				break
		}
	} catch (err) {
		console.log(err)
		result = sendResponse('error', err)
	}
	return result
}

function createImage(request, ss) {
	// make a google filename artistSurname_title_imageId
	// check imageFileName exists - overwrite or create!
	// create/update file in drive folder
	// rename with all relevant attributes
	// return entry image row

	console.log('createImage', request)
	// TODO Validate image
	try {
		// entryId, originalFileName, email, blobDataURL, imageFileName: artistSurname_title_id
		const imagesFolderName = 'Entry Images'
		const imageFileName = request.imageFileName
		const newImageFileName = request.newImageFileName
		const blobDataURL = request.blobDataURL
		const entryId = request.entryId

		// establish the image folder id
		const myFolder = wbLib.getMyFolder(ss)
		const imagesFolder = wbLib.checkIfFolderExistElseCreate(myFolder, imagesFolderName)

		// make a named blob from the dataURL from the user
		const { blob, mimeType } = dataURLtoBlob(blobDataURL)
		blob.setName(newImageFileName)

		// determine if an image file currently exists
		const fileIterator = imagesFolder.getFilesByName(imageFileName)
		const fileId = fileIterator.hasNext() ? fileIterator.next().getId() : ''

		// either create a file or update the existing one
		const fileClass =
			fileId === ''
				? imagesFolder.createFile(blob)
				: DriveApp.getFileById(Drive.Files.update({ title: newImageFileName }, fileId, blob).id)

		console.log(fileClass)

		const sheet = ss.getSheetByName('Entries')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]

		// // update the entry row
		// const rowToChange = wbLib.getRowFromColumnSearch(sheet.getDataRange().getValues(), "imageId", imageId)
		// if (rowToChange) {
		//   // update columns - imageURL, originalFileName
		//   imageURLColumn = headers.indexOf('imageURL') + 1
		//   sheet.getRange(rowToChange, imageURLColumn).setValues(newURL)

		//   originalFileNameColumn = headers.indexOf('originalFileName') + 1
		//   sheet.getRange(rowToChange, imageURLColumn).setValues(request.originalFileName)
		// }

		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		sheet.appendRow(row)
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function createRegistration(request, ss) {
	console.log('createRegistration', request)
	// TODO Validate entry
	if (!request.registrationId || request.registrationId.trim() === '') {
		return sendResponse('error', 'Invalid ID for create')
	}
	//create unique Regsitration ID
	request.registrationId = bumpId('registrationId')
	try {
		const sheet = ss.getSheetByName('Registrations')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		sheet.appendRow(row)
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function modifyRegistration(request, ss) {
	console.log('modifyRegistration', request)

	if (!request.registrationId || request.registrationId.trim() === '') {
		return sendResponse('error', 'Invalid ID for modify')
	}
	try {
		const sheet = ss.getSheetByName('Registrations')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		row.splice(1, 1, new Date())
		console.log('modifyRegistration')
		console.log(row)
		const rowToModify = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'registrationId',
			request.registrationId
		)
		if (rowToModify) {
			sheet.getRange(rowToModify, 1, 1, row.length).setValues([row])
		}
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function createEntry(request, ss) {
	console.log('createEntry', request)
	// TODO Validate entry
	//create unique Entry ID
	request.entryId = bumpId('entryId')
	try {
		const sheet = ss.getSheetByName('Entries')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		sheet.appendRow(row)
		const response = getFullRegistration(request.email, ss)
		// TODO SEND BACK THE ENTRY THAT WAS CREATED
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function deleteEntry(request, ss) {
	console.log('deleteEntry', request)

	if (!request.entryId || request.entryId.trim() === '') {
		return sendResponse('error', 'Invalid ID for delete')
	}
	try {
		const sheet = ss.getSheetByName('Entries')
		const rowToDelete = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'entryId',
			request.entryId
		)
		if (rowToDelete) {
			sheet.deleteRow(rowToDelete)
		}
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function modifyEntry(request, ss) {
	console.log('modifyEntry', request)

	if (!request.entryId || request.entryId.trim() === '') {
		return sendResponse('error', 'Invalid ID for modify')
	}
	try {
		const sheet = ss.getSheetByName('Entries')
		const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0]
		const row = headers.map((key) => request[String(key)] || '')
		console.log('modifyEntry')
		console.log(row)
		const rowToModify = wbLib.getRowFromColumnSearch(
			sheet.getDataRange().getValues(),
			'entryId',
			request.entryId
		)
		if (rowToModify) {
			sheet.getRange(rowToModify, 1, 1, row.length).setValues([row])
		}
		const response = getFullRegistration(request.email, ss)
		return sendResponse('ok', response.data)
	} catch (err) {
		console.log(err)
		return sendResponse('error', err)
	}
}

function getInformationForEmailAddress(request, ss) {
	if (!request.email || request.email.trim() === '') {
		return sendResponse('error', 'No email provided or invalid email address')
	}
	//now get the registration and all entries
	const response = getFullRegistration(request, ss)
	return sendResponse('ok', response.data)
}

function getFullRegistration(request, ss) {
	var registrationArray = getRegistrationByEmail(request.email, ss)
	if (typeof registrationArray !== 'undefined' && registrationArray.length !== 1) {
		return { data: { registration: {}, entries: [] } }
	}
	var entryArray = getEntriesByEmail(request.email, ss)
	return {
		data: { registration: registrationArray[0], entries: [...entryArray] }
	}
}

function getRegistrationByEmail(email, ss) {
	var registrationSheet = ss.getSheetByName('Registrations')
	const registrationData = registrationSheet.getDataRange().getValues()
	const allRegistrations = wbLib.getJsonArrayFromData(registrationData)
	var res = allRegistrations.filter((item) => item.email === email)
	return res
}

function getEntriesByEmail(email, ss) {
	const entrySheet = ss.getSheetByName('Entries')
	const entryData = entrySheet.getDataRange().getValues()
	const allEntries = wbLib.getJsonArrayFromData(entryData)

	const imageSheet = ss.getSheetByName('Images')
	const imageData = imageSheet.getDataRange().getValues()
	const allImages = wbLib.getJsonArrayFromData(imageData)

	// just the entries for the email we have
	const entriesForThisEmail = allEntries.filter((entry) => entry.email === email)

	// get the images linked with the entry id
	const entries = entriesForThisEmail.map((entry) => {
		const images = allImages.filter((imageItem) => imageItem.entryId === entry.id)
		return { ...entry, images }
	})

	// console.log(JSON.stringify(entries,null,2))
	return entries
}

function sendResponse(status, data) {
	try {
		return ContentService.createTextOutput(
			JSON.stringify({ result: status, data: data })
		).setMimeType(ContentService.MimeType.JSON)
	} catch (err) {
		console.log(err)
		return ContentService.createTextOutput(
			JSON.stringify({ result: 'error', data: err })
		).setMimeType(ContentService.MimeType.JSON)
	}
}

//**dataURL to blob**
function dataURLtoBlob(dataurl) {
	const arr = dataurl.split(',')
	const mimeType = arr[0].match(/:(.*?);/)[1]
	const myBlob = Utilities.base64Decode(arr[1])
	return {
		blob: Utilities.newBlob(myBlob, mimeType),
		mimeType
	}
}

/**
 * IDs are stored in a script property store using library functions
 *
 * ID is of the form 'xyzzy-nnn'
 * xyzzy can be any string  (not containing hyphen)
 * nnn is incrmented by 1
 *
 *
 * @param idType:String (registrationId | entryId | imageId)
 * @returns id:String
 *
 */
function bumpId(idType) {
	const prop = PropertiesService.getScriptProperties()
	const currentId = wbLib.getProp(idType, prop)
	let [frontPart, id] = currentId.split(/[/-]/)
	//increment the id part by 1 and zero fill to 3 chars
	const newId = (parseInt(id, 10) + 1).toString().padStart(3, '0')
	wbLib.setProp(idType, `${frontPart}-${newId}`, prop)
	return `${frontPart}-${newId}`
}
